//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Thu Dec 13 00:48:59 UTC 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_data_store                 O     1
// data_send                      O     1
// RDY_data_send                  O     1
// CLK_slow_clock                 O     1 clock
// CLK_GATE_slow_clock            O     1 const
// baud_rate                      I    32 unused
// clockSpeed                     I    32 unused
// CLK                            I     1 clock
// RST_N                          I     1 unused
// data_store_data                I     8
// EN_data_store                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTX(baud_rate,
	    clockSpeed,
	    CLK,
	    RST_N,

	    data_store_data,
	    EN_data_store,
	    RDY_data_store,

	    data_send,
	    RDY_data_send,

	    CLK_slow_clock,
	    CLK_GATE_slow_clock);
  input  [31 : 0] baud_rate;
  input  [31 : 0] clockSpeed;
  input  CLK;
  input  RST_N;

  // action method data_store
  input  [7 : 0] data_store_data;
  input  EN_data_store;
  output RDY_data_store;

  // value method data_send
  output data_send;
  output RDY_data_send;

  // oscillator and gates for output clock CLK_slow_clock
  output CLK_slow_clock;
  output CLK_GATE_slow_clock;

  // signals for module outputs
  wire CLK_GATE_slow_clock,
       CLK_slow_clock,
       RDY_data_send,
       RDY_data_store,
       data_send;

  // register count
  reg [3 : 0] count;
  wire [3 : 0] count$D_IN;
  wire count$EN;

  // ports of submodule c1
  wire c1$CLK_OUT;

  // ports of submodule data_fifo
  wire [9 : 0] data_fifo$dD_OUT, data_fifo$sD_IN;
  wire data_fifo$dDEQ, data_fifo$dEMPTY_N, data_fifo$sENQ, data_fifo$sFULL_N;

  // remaining internal signals
  wire [3 : 0] i__h350, x__h241;

  // oscillator and gates for output clock CLK_slow_clock
  assign CLK_slow_clock = c1$CLK_OUT ;
  assign CLK_GATE_slow_clock = 1'b1 ;

  // action method data_store
  assign RDY_data_store = data_fifo$sFULL_N ;

  // value method data_send
  assign data_send =
	     !data_fifo$dEMPTY_N ||
	     count != 4'd0 && data_fifo$dD_OUT[i__h350] ;
  assign RDY_data_send = data_fifo$dEMPTY_N ;

  // submodule c1
  ClockDiv #(.width(32'd8),
	     .lower(32'd58),
	     .upper(32'd196),
	     .offset(32'd0)) c1(.CLK_IN(CLK),
				.RST(!`BSV_RESET_VALUE),
				.PREEDGE(),
				.CLK_OUT(c1$CLK_OUT));

  // submodule data_fifo
  SyncFIFO #(.dataWidth(32'd10),
	     .depth(32'd4),
	     .indxWidth(32'd2)) data_fifo(.sCLK(CLK),
					  .dCLK(c1$CLK_OUT),
					  .sRST(!`BSV_RESET_VALUE),
					  .sD_IN(data_fifo$sD_IN),
					  .sENQ(data_fifo$sENQ),
					  .dDEQ(data_fifo$dDEQ),
					  .sFULL_N(data_fifo$sFULL_N),
					  .dEMPTY_N(data_fifo$dEMPTY_N),
					  .dD_OUT(data_fifo$dD_OUT));

  // register count
  assign count$D_IN = (count == 4'd10) ? 4'd0 : x__h241 ;
  assign count$EN = data_fifo$dEMPTY_N ;

  // submodule data_fifo
  assign data_fifo$sD_IN = { 2'd3, data_store_data } ;
  assign data_fifo$sENQ = EN_data_store ;
  assign data_fifo$dDEQ = data_fifo$dEMPTY_N && count == 4'd10 ;

  // remaining internal signals
  assign i__h350 = count - 4'd1 ;
  assign x__h241 = count + 4'd1 ;

  // handling of inlined registers

  always@(posedge c1$CLK_OUT)
  begin
    if (!`BSV_RESET_VALUE == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkTX

